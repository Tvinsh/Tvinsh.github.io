<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>tomato</title>
	<meta name="keywords" content="tomato的博客，tomato，最帅的博客，前端博客，javascript,html,css,nodejs,pwa，amp">
	<meta name="description" content="tomato的博客，tomato，最帅的博客，前端博客，javascript,html,css,nodejs,pwa，amp">
	<meta name="viewport" content="user-scalable=no,width=718">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="baidu-site-verification" content="HY5hBj9CX6" />
	<meta name="robots" content="all">
    <meta name="googlebot" content="all">
    <meta name="baiduspider" content="all">
    <meta name="format-detection" content="telephone=no">
    <link rel="manifest" href="/manifest.json">
    
	  <link rel="amphtml" href="./amp/index.html">
	
	<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="rss">
	<!-- <link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css"> -->
	<link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/mono-blue.min.css" rel="stylesheet">
	<script src="https://cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
	<link rel="stylesheet" href="/css/i.css">
	<link rel="stylesheet" href="/css/cmts.css">
	<link rel="stylesheet" href="/css/arc.0.4.css">
	<link rel="canonical" href="https://2fz1.me/2018/01/16/pwa/">
	<script type="text/javascript">
		var host = "2fz1.me";
		if ((host == window.location.host) && (window.location.protocol != "https:"))
			window.location.protocol = "https";
	</script>
</head>
<body>
	<nav class="nav">
	<a href="/" class="true home" ><img src="/image/me.jpeg">tomato</a>
	<a href="/archives/" title="连续不断的奇迹" class="false" ><img src="/image/design/nichijou.svg">归档</a>
	<a href="/tags/" title="{1+1>2}" class="false eltag" ><img src="/image/design/tag.svg">tag</a>
	<a href="https://2fz1.me/blogDemos" target="_blank" title="{1+1>2}" class="false"><img src="/image/design/code.svg">Demo</a>
	<a href="https://2fz1.me/blogDemos/photos/index.html" target="_blank" class="false"><img src="/image/design/feel.svg">图片</a>
	<!-- <a href="#!home" ><img src="/image/design/vsco.svg">VSCO</a> -->
	<a href="https://github.com/Tvinsh/slides/blob/master/README.md" target="_blank" class="false"><img src="/image/design/photo.svg">分享</a>
	<a href="/about" class="false"><img src="/image/design/link.svg">About</a>
</nav>
	<div id="m">
		<div id="S">
	<div class="I">
		<form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="键入内容启用google搜索"><input type="hidden" name="sitesearch" value="https://2fz1.me"></form>
	</div>
	<ul id="Sl" class="h">
		<li>
			<a>
				<h3>键入内容启用google搜索</h3>
			</a>
		</li>
	</ul>
</div>

		
		
		<article class="p">
	<div class="p-text">
		<p><p><img src="/img/pwa.png" alt="图片内容"></p>
<h1 id="PWA-初探"><a href="#PWA-初探" class="headerlink" title="PWA 初探"></a>PWA 初探</h1><hr>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>简单介绍下，PWA 全名 Progressive Web Apps 即 渐进式网络应用， 是 Google 提出的用前沿的 Web 技术为网页提供 App 般使用体验的一系列方案。</p>
<p>和 PWA 相关的其实包含很多内容，这里我们重点探讨下和 webapp 有关的一些内容。 PWA 具有很多优势，比如以下：</p>
<blockquote>
<ol>
<li>免安装，可添加快捷方式到桌面，类似原生app体验,敏捷更新</li>
<li>响应式</li>
<li>独立于网络连接</li>
<li>可发现, 可重连, 可链接</li>
</ol>
</blockquote>
<p>这里面有很多功能是对传统 webapp 的巨大突破，这应该也是 PWA 这么火热的原因。</p>
<h3 id="主要技术点"><a href="#主要技术点" class="headerlink" title="主要技术点"></a>主要技术点</h3><p>PWA 包括一系列的技术点，其中比较重要的包括：</p>
<blockquote>
<ol>
<li>Service Worker</li>
<li>Web App Manifest</li>
<li>App Shell</li>
<li>Push Notification</li>
</ol>
</blockquote>
<p>这其中，Service Workers 是 PWA 的关键，其中包括 Cache API、 Fetch API 等技术点，下面我们简单介绍下这些技术，通过了解这些技术可以大致了解 PWA 究竟是什么。</p>
<h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><blockquote>
<p>Service Worker 是一段脚本，与 Web Worker 一样，也是在后台运行。作为一个独立的线程，运行环境与普通脚本不同，所以不能直接参与 Web 交互行为。Native App 可以做到离线使用、消息推送、后台自动更新，Service Worker 的出现是正是为了使得 Web App 也可以具有类似的能力。</p>
</blockquote>
<p>简单概括下即 No window，No DOM，NO XHR，NO localStorage。<br>在 Service Worker 当中会用到一些全局变量:</p>
<blockquote>
<ol>
<li>self: 表示 Service Worker 作用域, 也是全局变量</li>
<li>caches: 表示缓存</li>
<li>skipWaiting: 表示强制当前处在 waiting 状态的脚本进入 activate 状态</li>
<li>clients: 表示 Service Worker 接管的页面</li>
</ol>
</blockquote>
<h5 id="servive-worker-生命周期："><a href="#servive-worker-生命周期：" class="headerlink" title="servive worker 生命周期："></a>servive worker 生命周期：</h5><p><img src="/img/service1.jpg" alt="生命周期"></p>
<blockquote>
<ol>
<li>parsed: 注册完成, 脚本解析成功, 尚未安装</li>
<li>installing: 对应 Service Worker 脚本 install 事件执行, 如果事件里有 event.waitUntil() 则会等待传入的 Promise 完成才会成功</li>
<li>installed(waiting): 页面被旧的 Service Worker 脚本控制, 所以当前的脚本尚未激活。可以通过 self.skipWaiting() 激活新的 Service Worker</li>
<li>activating: 对应 Service Worker 脚本 activate 事件执行, 如果事件里有 event.waitUntil() 则会等待这个 Promise 完成才会成功。这时可以调用 Clients.claim() 接管页面</li>
<li>activated: 激活成功, 可以处理 fetch, message 等事件</li>
<li>redundant: 安装失败, 或者激活失败, 或者被新的 Service Worker 替代掉</li>
</ol>
</blockquote>
<h5 id="server-worker-和主页面通信："><a href="#server-worker-和主页面通信：" class="headerlink" title="server worker 和主页面通信："></a>server worker 和主页面通信：</h5><p>server worker 主要通过 postMessage 来发送信息，通过监听 message 事件来获得信息，具体请看以下示例 –&gt; <a href="https://2fz1.me/blogDemos/sw/index.html">server worker通信</a></p>
<h5 id="server-worker-截获请求和缓存"><a href="#server-worker-截获请求和缓存" class="headerlink" title="server worker 截获请求和缓存"></a>server worker 截获请求和缓存</h5><p>Service Worker 脚本最常用的功能是截获请求和缓存资源文件, 这些行为可以绑定在下面这些事件上:</p>
<blockquote>
<ol>
<li>install 事件中, 抓取资源进行缓存</li>
<li>activate 事件中, 遍历缓存, 清除过期的资源</li>
<li>fetch 事件中, 拦截请求, 查询缓存或者网络, 返回请求的资源</li>
</ol>
</blockquote>
<h3 id="Web-App-Manifest"><a href="#Web-App-Manifest" class="headerlink" title="Web App Manifest"></a>Web App Manifest</h3><p>官网上对于其的解释:</p>
<blockquote>
<p>Web 应用清单文件是简单的 JSON 文件，它在文本文件中提供了应用相关的有用信息 (比如应用的名称、作者、图标和描述)。但更特别的是，Web 应用清单可使用户将 Web 应用安装到设备的主屏幕上，并允许开发者自定义启动画面、模板颜色，甚至是打开的 URL 。</p>
</blockquote>
<p>实际应用中，我们需要定义一个 <code>manifest.json</code> 文件，并将其引入 html 中 <code>&lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot; /&gt;</code></p>
<p>manifest.json 大致结构如下：</p>
<pre><code class="json">{
    &quot;name&quot;: &quot;Qi Dian web app&quot;,
    &quot;short_name&quot;: &quot;QiDian&quot;,
    &quot;start_url&quot;: &quot;/index.html&quot;,
    &quot;display&quot;: &quot;standalone&quot;,
    &quot;theme_color&quot;: &quot;#FFDF00&quot;,
    &quot;background_color&quot;: &quot;#FFDF00&quot;,
    &quot;icons&quot;: [{
        &quot;src&quot;: &quot;homescreen.png&quot;,
        &quot;sizes&quot;: &quot;192x192&quot;,
        &quot;type&quot;: &quot;image/png&quot;
        },
        {
        &quot;src&quot;: &quot;homescreen-144.png&quot;,
        &quot;sizes&quot;: &quot;144x144&quot;,
        &quot;type&quot;: &quot;image/png&quot;
        }
    ]
}
</code></pre>
<p>json 定义了以下内容：</p>
<blockquote>
<ol>
<li>name 用作当用户被提示安装应用时出现的文本</li>
<li>short_name 用作当应用安装后出现在用户主屏幕上的文本</li>
<li>start_url 决定了当用户从设备的主屏幕开启 Web 应用时所出现的第一个页面</li>
<li>display 打开后如何显示，如是否全屏，是否在浏览器中打开等</li>
<li>theme_color 可以对浏览器的地址栏进行着色</li>
<li>icons 字段决定了当 Web 应用被添加到设备主屏幕时所显示的图标</li>
</ol>
</blockquote>
<h3 id="App-Shell"><a href="#App-Shell" class="headerlink" title="App Shell"></a>App Shell</h3><p>为了使 webapp 体验起来更像原生应用，结合 webapp 的外壳几乎没太大变化，比如导航栏，头部，底部等，我们可以通过之前说的 service worker 将 webapp 的外层ui框架缓存起来，当首次加载时缓存了 ui 框架，后面再访问时，就会立即出现已经缓存的ui框架，然后加载后续资源，给用户一种原生app的体验。</p>
<p><img src="/img/app-shell.png" alt="appshell"></p>
<h3 id="Push-Notification"><a href="#Push-Notification" class="headerlink" title="Push Notification"></a>Push Notification</h3><p>推送通知可能是 PWA 比较吸引人的一个点了，推送通知可以很好的与用户进行互动，尤其是当他们关闭了标签页或访问其他网页的时候，即使用户没有浏览你的网站也会收到这些通知。</p>
</p>
	</div>
	<div id="busuanzi_container_page_pv"  class="pvcount pagecount">This page total <span class="pvnumber" id="busuanzi_value_site_pv"></span> views</div>
</article>
	</div>
</body>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script>
	hljs.initHighlightingOnLoad();
	// 注册service worker
	if (navigator.serviceWorker != null) {
      navigator.serviceWorker.register('/service-worker.js')
      .then(function(registration) {
        console.log('Registered events at scope: ', registration.scope);
      });
    }
</script>
</html>